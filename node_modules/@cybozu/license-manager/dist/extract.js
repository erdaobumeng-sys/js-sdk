"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.extract = void 0;
const fs_1 = __importDefault(require("fs"));
const path_1 = __importDefault(require("path"));
const picocolors_1 = __importDefault(require("picocolors"));
const aggregate_1 = require("./functions/aggregate");
const depsUtils_1 = require("./functions/depsUtils");
const loadConfigScript_1 = require("./functions/loadConfigScript");
const detectPackageManager_1 = require("./functions/detectPackageManager");
const extract = async ({ configFilePath, ...cliArgs }) => {
    console.log("ðŸ”ª Extract licenses...");
    const config = await (0, loadConfigScript_1.loadConfigScript)(configFilePath);
    const args = mergeConfig(cliArgs, config);
    const dependencies = await (0, aggregate_1.aggregate)(args.packageManager, args.query, args.cwd, args.workspace, args.excludePackages, config);
    const targetDependencies = dependencies.filter((dep) => {
        if (args.extractLicenses.length && !args.extractLicenses.some((pattern) => (0, depsUtils_1.isMatchLicense)(dep, pattern))) {
            return false;
        }
        if (args.excludePackages.some((pkg) => (0, depsUtils_1.isMatchPackage)(dep, pkg))) {
            return false;
        }
        return true;
    });
    // check license text
    const licenseNotFoundDeps = targetDependencies
        .filter((dep) => !dep.licenseText)
        .map((dep) => `${dep.name}@${dep.version}`);
    if (licenseNotFoundDeps.length) {
        console.error(picocolors_1.default.red("ðŸš¨ License text not found"));
        licenseNotFoundDeps.forEach((txt) => {
            console.error(picocolors_1.default.red(txt));
        });
        process.exit(1);
    }
    let writeFilePath;
    if (args.json) {
        writeFilePath = outputDepsAsJSON(targetDependencies, args.output);
    }
    else {
        writeFilePath = outputDepsAsText(targetDependencies, args.output);
    }
    console.log(picocolors_1.default.green(`âœ… Extracted to ${writeFilePath}`));
};
exports.extract = extract;
const mergeConfig = (args, config) => {
    return {
        query: args.query || config.extract?.query || ":root .prod",
        cwd: args.cwd || config.cwd || "",
        workspace: args.workspace || config.workspace || "",
        extractLicenses: [...args.extractLicenses, ...(config.extract?.extractLicenses || [])],
        excludePackages: [...args.excludePackages, ...(config.extract?.excludePackages || [])],
        output: args.output || config.extract?.output || "",
        json: args.json || config.extract?.format === "json",
        packageManager: args.packageManager || config.packageManager || (0, detectPackageManager_1.detectPackageManager)(),
    };
};
const outputDepsAsText = (deps, output) => {
    const licenseText = deps
        .map((dep) => {
        const values = [dep.name];
        dep.author && values.push(`author: ${getAuthor(dep)}`);
        dep.repository && values.push(`repository: ${getRepository(dep)}`);
        dep.license && values.push(`license: ${dep.license}`);
        dep.licenseText && values.push(`${dep.licenseText}`);
        dep.apacheNotice && values.push(`${dep.apacheNotice}`);
        return values.join("\n");
    })
        .join(`\n\n\n`);
    const writeFilePath = path_1.default.join(process.cwd(), output || "licenses.txt");
    const dir = path_1.default.dirname(writeFilePath);
    if (!fs_1.default.existsSync(dir)) {
        fs_1.default.mkdirSync(dir, { recursive: true });
    }
    fs_1.default.writeFileSync(writeFilePath, licenseText);
    return writeFilePath;
};
const outputDepsAsJSON = (deps, output) => {
    const writeFilePath = path_1.default.join(process.cwd(), output || "licenses.json");
    const dir = path_1.default.dirname(writeFilePath);
    if (!fs_1.default.existsSync(dir)) {
        fs_1.default.mkdirSync(dir, { recursive: true });
    }
    fs_1.default.writeFileSync(writeFilePath, JSON.stringify(deps, null, 2));
    return writeFilePath;
};
const getAuthor = ({ author }) => {
    if (!author)
        return "";
    if (typeof author === "string")
        return author;
    const name = author.name;
    const email = author.email ? `<${author.email}>` : "";
    const url = author.url ? `(${author.url})` : "";
    return `${name}${email}${url}`;
};
const getRepository = ({ repository }) => {
    if (!repository)
        return "";
    if (typeof repository === "string")
        return repository;
    return repository.url;
};
