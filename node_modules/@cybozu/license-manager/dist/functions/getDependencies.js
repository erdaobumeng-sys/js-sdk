"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDependenciesForPnpm = exports.getDependenciesForNpm = void 0;
const node_child_process_1 = require("node:child_process");
const node_util_1 = require("node:util");
const promises_1 = require("node:fs/promises");
const node_path_1 = require("node:path");
const picocolors_1 = __importDefault(require("picocolors"));
const exec = (0, node_util_1.promisify)(node_child_process_1.exec);
const getDependenciesForNpm = async (npmQueryString, cwd, workspace) => {
    const workspaceOption = workspace ? ` -ws ${workspace}` : "";
    const command = `npm query "${npmQueryString}"${workspaceOption}`;
    const { stdout, stderr } = await exec(command, { maxBuffer: 10000 * 1024, cwd: cwd || undefined });
    if (stderr) {
        console.warn(`ðŸš¨ ${picocolors_1.default.bgYellow("npm query : stderr")} ${stderr}`);
    }
    return JSON.parse(stdout);
};
exports.getDependenciesForNpm = getDependenciesForNpm;
const getDependenciesForPnpm = async (option, cwd, workspace) => {
    const workspaceOption = workspace ? ` --filter ${workspace}` : "";
    const command = `pnpm licenses list --json ${option}${workspaceOption}`;
    const { stdout, stderr } = await exec(command, { maxBuffer: 10000 * 1024, cwd: cwd || undefined });
    if (stderr) {
        console.warn(`ðŸš¨ ${picocolors_1.default.bgYellow("pnpm license list : stderr")} ${stderr}`);
    }
    const rawLicenses = JSON.parse(stdout);
    const promises = Object.values(rawLicenses).flatMap((deps) => deps.flatMap((dep) => {
        const { name, license } = dep;
        if ("paths" in dep) {
            const { versions } = dep;
            return dep.paths.map(async (path, index) => {
                const { author, repository } = await getPackageJsonFields(path);
                return {
                    name,
                    license,
                    version: versions[index],
                    path,
                    ...(author && { author }),
                    ...(repository && { repository }),
                };
            });
        }
        return [
            (async () => {
                const { author, repository } = await getPackageJsonFields(dep.path);
                return {
                    name,
                    license,
                    version: dep.version,
                    path: dep.path,
                    ...(author && { author }),
                    ...(repository && { repository }),
                };
            })(),
        ];
    }));
    return Promise.all(promises);
};
exports.getDependenciesForPnpm = getDependenciesForPnpm;
const getPackageJsonFields = async (packagePath) => {
    const packageJsonPath = (0, node_path_1.join)(packagePath, "package.json");
    try {
        const packageJsonContent = await (0, promises_1.readFile)(packageJsonPath, "utf-8");
        const packageJson = JSON.parse(packageJsonContent);
        return {
            author: packageJson.author,
            repository: packageJson.repository,
        };
    }
    catch (error) {
        // If we can't read the package.json, just skip adding author and repository
        return { author: undefined, repository: undefined };
    }
};
